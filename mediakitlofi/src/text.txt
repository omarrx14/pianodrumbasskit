import React from 'react';
import { Provider } from 'react-redux';
import store from './App/store.ts';
import './App.css';
import WindowComponent from './WindowComponent';
import WindowComponent2 from './WindowComponent2';
import WindowComponent3 from './WindowsComponent3';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { NotesProvider, SnapValueProvider, PlayingProvider } from './App/components/context.js';

function App() {
    return (
        <Provider store={store}>
            <DndProvider backend={HTML5Backend}>
                <NotesProvider>
                    <SnapValueProvider>
                        <PlayingProvider>
                            <div className="App">
                                {/* Comenta o descomenta según necesites usar estos componentes */}
                                {/* <WindowComponent /> */}
                                {/* <WindowComponent2 /> */}
                                <WindowComponent3 />
                            </div>
                        </PlayingProvider>
                    </SnapValueProvider>
                </NotesProvider>
            </DndProvider>
        </Provider>
    );
}

export default App;

import React from 'react';
import { Provider } from 'react-redux';
import store from './App/store.ts';
import './App.css';
import WindowComponent from './WindowComponent';
import WindowComponent2 from './WindowComponent2';
import WindowComponent3 from './WindowsComponent3';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';

function App() {
    return (
        <Provider store={store}>
            <DndProvider backend={HTML5Backend}>
                <div className="App">
                    {/* <WindowComponent /> */}
                    {/* <WindowComponent2 /> */}
                    <WindowComponent3 />
                </div>
            </DndProvider>
        </Provider>
    );
}

export default App;


// Timeline.tsx
import React, { useEffect, useState } from 'react';
import { useDrop } from 'react-dnd';
import { useDispatch, useSelector } from 'react-redux';
import { addChord, togglePlay, setCurrentTime, updateMatrix, setBpm, setPosition, insertInMatrix, notes, setSelectedCellsCount, moveBlock, actualizarDuracionNota, addNote } from './timelineslice.ts'; // Importa las acciones necesarias
import * as Tone from 'tone';
import './timeline.css';
import './pianokey1.css';
import PianoRoll from './pianopixiroll.js';
import Cell from './Cell.tsx';
import './pianroll.css'; // Asegúrate de crear este archivo CSS para estilizar tu piano roll
import SliderComponent from './sliderui.js';
import Bar from './bar1.tsx';
import { Gridtest } from './Gridtest.tsx';


import PianoKey from './Pianokeys1.js';



export const Timeline: React.FC = () => {
    const synth = new Tone.PolySynth(Tone.Synth).toDestination();
    const dispatch = useDispatch();
    const { chords, isPlaying, currentTime, matrix, pianoRoll } = useSelector((state) => state.timeline);
    const [bpm, setBpm] = useState(120); // Valor inicial de 120 BPM
    const [isDragging] = useState(false);
    const [draggingBar, setDraggingBar] = useState(null);
    const [seleccionActual, setSeleccionActual] = useState(null);
    const { slots } = useSelector((state) => state.timeline);


    console.log('Matrix State:', matrix); // Ver el estado actual de la matriz

    const [, drop] = useDrop({
        accept: 'chord',
        drop: (item: any, monitor) => {
            console.log('Dropped item:', item); // Ver el objeto arrastrado

            const clientOffset = monitor.getClientOffset();
            console.log('Client Offset:', clientOffset); // Ver la posición del evento de soltar

            if (clientOffset) {
                const row = calculateRow(clientOffset.y);
                const col = calculateCol(clientOffset.x);
                console.log('Calculated row and col:', row, col); // Ver la fila y columna calculadas

                dispatch(updateMatrix({ chord: item.chord, row, col }));
            }
        },
    });

    const pianoNotes = [
        { note: "C5", type: "white", velocity: ".05" }, { note: "C#4", type: "black" }, { note: "D4", type: "white" },
        { note: "D#4", type: "black" }, { note: "E4", type: "white" }, { note: "F4", type: "white" },
        { note: "F#4", type: "black" }, { note: "G4", type: "white" }, { note: "G#4", type: "black" },
        { note: "A4", type: "white" }, { note: "A#4", type: "black" }, { note: "B4", type: "white" }
    ];




    const transformNoteStartTime = (compass, corchea) => {
        return `${compass}:${corchea}`
    }

    const notesToTonejsNotes = () => {
        const values = Object.entries(pianoRoll).map(([clave, valor]) => {
            return {
                note: valor.note,
                time: transformNoteStartTime(valor.compass, valor.corchea),
                duration: calcularDuracionToneJs(valor.duration)
            };
        });

        console.log(values)
        return values;
    }


    // useEffect(() => {
    //     const tonejsNotes = notesToTonejsNotes()
    //     // Asegúrate de que Tone.js esté listo
    //     Tone.start();

    //     // Crea un sintetizador
    //     const synth = new Tone.Synth().toDestination();
    //     const parte = new Tone.Part((time, value) => {
    //         synth.triggerAttackRelease(value.note, value.duration, time);
    //     }, tonejsNotes).start(0);

    //     // Configura el tempo (BPM)
    //     Tone.Transport.bpm.value = 120;

    //     // Inicia el transporte para tocar las notas
    //     Tone.Transport.start();
    // }, [pianoRoll]);


    useEffect(() => {
        if (isPlaying) {
            const intervalTime = (60 / bpm) * 1000; // Convertir BPM a intervalo en milisegundos
            const interval = setInterval(() => {
                const nextTime = currentTime + 1;


                playChordsAtTime(nextTime);
            }, intervalTime);

            return () => clearInterval(interval);
        }
    }, [isPlaying, currentTime, bpm, setPosition, dispatch]);


    const playChordsAtTime = (time) => {
        // Iterar a través de cada fila de la matriz
        matrix.forEach((row, rowIndex) => {
            // Obtener el acorde en la columna que corresponde al tiempo actual
            const cell = row[time];
            if (cell && cell.chord) {
                // Reproducir el acorde si existe en la celda actual
                synth.triggerAttackRelease(cell.chord.notes, '8n');
            }
        });
    };
    const handlePlay = async () => {

        // Asegúrate de que Tone.js esté listo para iniciar la reproducción de audio
        Tone.start().then(() => {
            // Convierte las notas de tu piano roll al formato esperado por Tone.js
            const toneJSNotes = notesToTonejsNotes(pianoRoll);

            // Crea un PolySynth y lo conecta al destino de audio
            const polySynth = new Tone.PolySynth(Tone.Synth).toDestination();

            // Crea una parte con las notas convertidas y las programa para su reproducción
            const parte = new Tone.Part((time, value) => {
                // Toca cada nota en su tiempo especificado
                polySynth.triggerAttackRelease(value.note, value.duration, time, value.velocity);
                // Opcionalmente, imprime un mensaje en la consola cada vez que se toca una nota
                console.log('Nota tocada en el tiempo:', time);
            }, toneJSNotes).start(0);

            // Configura el tempo (BPM)
            Tone.Transport.bpm.value = 80;

            // Inicia el transporte de Tone.js para comenzar la reproducción
            Tone.Transport.start();
        });
    };

    // Función para detener la reproducción
    const handleStop = () => {
        // Detiene el transporte de Tone.js y cancela eventos programados
        Tone.Transport.cancel();

        Tone.Transport.stop();
        Tone.Transport.seconds = 0;

    };



    function calcularDuracionToneJs(cuadritos) {
        // Asegúrate de que Tone.js esté importado o accesible en este contexto
        // Cada cuadrito es una semicorchea ("16n")
        if (cuadritos === 1) {
            return "16n"; // Un cuadrito es directamente una semicorchea
        } else if (cuadritos % 4 === 0) {
            // Si la cantidad de cuadritos es un múltiplo de 4, entonces es una corchea ("8n"), negra ("4n"), etc.
            const division = cuadritos / 4;
            if (division === 1) return "4n"; // Negra
            else if (division === 2) return "2n"; // Blanca
            else if (division === 4) return "1n"; // Redonda
            // Para duraciones más largas, ajusta según sea necesario
        } else {
            // Para duraciones que no encajan perfectamente en la notación estándar
            // Podemos devolver la duración como una combinación de notas y silencios, o manejar de otra manera
            // Por simplicidad, devolveremos la cantidad de "cuadritos" como "16n" concatenados, aunque esto no es ideal
            return Array(cuadritos).fill("16n").join(","); // Esto es una simplificación y puede no ser lo que deseas exactamente
        }

        // Caso por defecto, devuelve la cantidad de cuadritos como "16n" si no se cumple ninguna condición
        return Array(cuadritos).fill("16n").join(",");
    };

    // Ejemplo de uso
    console.log(calcularDuracionToneJs(4)); // Debería devolver "4n"
    console.log(calcularDuracionToneJs(8)); // Debería devolver "2n"
    console.log(calcularDuracionToneJs(3)); // Devuelve "16n,16n,16n" como








    // const odeToJoyPatterns = {
    //     melody: [
    //         // Parte inicial de la melodía de "Ode to Joy"
    //         ['0:0:0', 'E4'],
    //         ['0:0:2', 'E4'],
    //         ['0:1:0', 'F4'],
    //         ['0:1:2', 'G4'],
    //         ['0:2:0', 'G4'],
    //         ['0:2:2', 'F4'],
    //         ['0:3:0', 'E4'],
    //         ['0:3:2', 'D4'],
    //         ['1:0:0', 'C4'],
    //         ['1:0:2', 'C4'],
    //         ['1:1:0', 'D4'],
    //         ['1:1:2', 'E4'],
    //         ['1:2:0', 'E4'],
    //         ['1:2:2', 'D4'],
    //         ['1:3:0', 'D4'],
    //         // Repite o continúa la melodía según sea necesario
    //     ],
    //     // Puedes agregar acordes o acompañamiento si lo deseas
    // };

    // let melodyPart = new Tone.Part((time, note) => {
    //     synth.triggerAttackRelease(note, '8n', time);
    // }, odeToJoyPatterns.melody).start(0);

    // melodyPart.loop = true;
    // melodyPart.loopStart = 0;
    // melodyPart.loopEnd = '2:0:0';

    const handleChangeBpm = (e) => {
        const newBpm = Number(e.target.value);
        setBpmLocal(newBpm);
        dispatch(setBpmAction(newBpm)); // Actualiza el BPM en Redux
    };

    return (
        <div>
            <div className="piano">
                {pianoNotes.map(({ note, type }) => (
                    <PianoKey key={note} note={note} type={type} />
                ))}
            </div>

            <button onClick={handlePlay}>Play</button>
            <button onClick={handleStop}>Stop</button>

            <div className="pianoRoll">
                <Gridtest slots={slots}
                />
            </div>

            <div>
                <label htmlFor="bpm">BPM:</label>
                <input
                    type="number"
                    id="bpm"
                    value={bpm}
                    onChange={handleChangeBpm}
                />
            </div>
        </div>
    );
};















// Timeline.tsx
import React, { useEffect, useState } from 'react';
import { useDrop } from 'react-dnd';
import { useDispatch, useSelector } from 'react-redux';
import { addChord, togglePlay, setCurrentTime, updateMatrix, setBpm, setPosition, insertInMatrix, notes, setSelectedCellsCount, moveBlock, actualizarDuracionNota, addNote } from './timelineslice.ts'; // Importa las acciones necesarias
import * as Tone from 'tone';
import './timeline.css';
import './pianokey1.css';
import PianoRoll from './pianopixiroll.js';
import Cell from './Cell.tsx';
import './pianroll.css'; // Asegúrate de crear este archivo CSS para estilizar tu piano roll
import SliderComponent from './sliderui.js';
import Bar from './bar1.tsx';
import { GridTest } from './Gridtest.tsx'


import PianoKey from './Pianokeys1.js';



export const Timeline: React.FC = () => {
    const synth = new Tone.PolySynth(Tone.Synth).toDestination();
    const dispatch = useDispatch();
    const { chords, isPlaying, currentTime, matrix, pianoRoll } = useSelector((state) => state.timeline);
    const [bpm, setBpm] = useState(120); // Valor inicial de 120 BPM
    const [isDragging] = useState(false);
    const [draggingBar, setDraggingBar] = useState(null);
    const [seleccionActual, setSeleccionActual] = useState(null);


    console.log('Matrix State:', matrix); // Ver el estado actual de la matriz

    const [, drop] = useDrop({
        accept: 'chord',
        drop: (item: any, monitor) => {
            console.log('Dropped item:', item); // Ver el objeto arrastrado

            const clientOffset = monitor.getClientOffset();
            console.log('Client Offset:', clientOffset); // Ver la posición del evento de soltar

            if (clientOffset) {
                const row = calculateRow(clientOffset.y);
                const col = calculateCol(clientOffset.x);
                console.log('Calculated row and col:', row, col); // Ver la fila y columna calculadas

                dispatch(updateMatrix({ chord: item.chord, row, col }));
            }
        },
    });

    const pianoNotes = [
        { note: "C5", type: "white", velocity: ".05" }, { note: "C#4", type: "black" }, { note: "D4", type: "white" },
        { note: "D#4", type: "black" }, { note: "E4", type: "white" }, { note: "F4", type: "white" },
        { note: "F#4", type: "black" }, { note: "G4", type: "white" }, { note: "G#4", type: "black" },
        { note: "A4", type: "white" }, { note: "A#4", type: "black" }, { note: "B4", type: "white" }
    ];




    const transformNoteStartTime = (compass, corchea) => {
        return `${compass}:${corchea}`
    }

    const notesToTonejsNotes = () => {
        const values = Object.entries(pianoRoll).map(([clave, valor]) => {
            return {
                note: valor.note,
                time: transformNoteStartTime(valor.compass, valor.corchea),
                duration: calcularDuracionToneJs(valor.duration)
            };
        });

        console.log(values)
        return values;
    }


    // useEffect(() => {
    //     const tonejsNotes = notesToTonejsNotes()
    //     // Asegúrate de que Tone.js esté listo
    //     Tone.start();

    //     // Crea un sintetizador
    //     const synth = new Tone.Synth().toDestination();
    //     const parte = new Tone.Part((time, value) => {
    //         synth.triggerAttackRelease(value.note, value.duration, time);
    //     }, tonejsNotes).start(0);

    //     // Configura el tempo (BPM)
    //     Tone.Transport.bpm.value = 120;

    //     // Inicia el transporte para tocar las notas
    //     Tone.Transport.start();
    // }, [pianoRoll]);


    useEffect(() => {
        if (isPlaying) {
            const intervalTime = (60 / bpm) * 1000; // Convertir BPM a intervalo en milisegundos
            const interval = setInterval(() => {
                const nextTime = currentTime + 1;


                playChordsAtTime(nextTime);
            }, intervalTime);

            return () => clearInterval(interval);
        }
    }, [isPlaying, currentTime, bpm, setPosition, dispatch]);


    const playChordsAtTime = (time) => {
        // Iterar a través de cada fila de la matriz
        matrix.forEach((row, rowIndex) => {
            // Obtener el acorde en la columna que corresponde al tiempo actual
            const cell = row[time];
            if (cell && cell.chord) {
                // Reproducir el acorde si existe en la celda actual
                synth.triggerAttackRelease(cell.chord.notes, '8n');
            }
        });
    };
    const handlePlay = async () => {

        // Asegúrate de que Tone.js esté listo para iniciar la reproducción de audio
        Tone.start().then(() => {
            // Convierte las notas de tu piano roll al formato esperado por Tone.js
            const toneJSNotes = notesToTonejsNotes(pianoRoll);

            // Crea un PolySynth y lo conecta al destino de audio
            const polySynth = new Tone.PolySynth(Tone.Synth).toDestination();

            // Crea una parte con las notas convertidas y las programa para su reproducción
            const parte = new Tone.Part((time, value) => {
                // Toca cada nota en su tiempo especificado
                polySynth.triggerAttackRelease(value.note, value.duration, time, value.velocity);
                // Opcionalmente, imprime un mensaje en la consola cada vez que se toca una nota
                console.log('Nota tocada en el tiempo:', time);
            }, toneJSNotes).start(0);

            // Configura el tempo (BPM)
            Tone.Transport.bpm.value = 80;

            // Inicia el transporte de Tone.js para comenzar la reproducción
            Tone.Transport.start();
        });
    };

    // Función para detener la reproducción
    const handleStop = () => {
        // Detiene el transporte de Tone.js y cancela eventos programados
        Tone.Transport.cancel();

        Tone.Transport.stop();
        Tone.Transport.seconds = 0;

    };



    function calcularDuracionToneJs(cuadritos) {
        // Asegúrate de que Tone.js esté importado o accesible en este contexto
        // Cada cuadrito es una semicorchea ("16n")
        if (cuadritos === 1) {
            return "16n"; // Un cuadrito es directamente una semicorchea
        } else if (cuadritos % 4 === 0) {
            // Si la cantidad de cuadritos es un múltiplo de 4, entonces es una corchea ("8n"), negra ("4n"), etc.
            const division = cuadritos / 4;
            if (division === 1) return "4n"; // Negra
            else if (division === 2) return "2n"; // Blanca
            else if (division === 4) return "1n"; // Redonda
            // Para duraciones más largas, ajusta según sea necesario
        } else {
            // Para duraciones que no encajan perfectamente en la notación estándar
            // Podemos devolver la duración como una combinación de notas y silencios, o manejar de otra manera
            // Por simplicidad, devolveremos la cantidad de "cuadritos" como "16n" concatenados, aunque esto no es ideal
            return Array(cuadritos).fill("16n").join(","); // Esto es una simplificación y puede no ser lo que deseas exactamente
        }

        // Caso por defecto, devuelve la cantidad de cuadritos como "16n" si no se cumple ninguna condición
        return Array(cuadritos).fill("16n").join(",");
    };

    // Ejemplo de uso
    console.log(calcularDuracionToneJs(4)); // Debería devolver "4n"
    console.log(calcularDuracionToneJs(8)); // Debería devolver "2n"
    console.log(calcularDuracionToneJs(3)); // Devuelve "16n,16n,16n" como


    const handleCellClick = (rowIndex, colIndex) => {
        const octavaC4aB4 = {
            0: "C4",
            1: "C#4 / Db4",
            2: "D4",
            3: "D#4 / Eb4",
            4: "E4",
            5: "F4",
            6: "F#4 / Gb4",
            7: "G4",
            8: "G#4 / Ab4",
            9: "A4",
            10: "A#4 / Bb4",
            11: "B4"
        };
        const note = octavaC4aB4[rowIndex];


        dispatch(insertInMatrix({ rowIndex, columnIndex: colIndex, note }));
    };





    // const odeToJoyPatterns = {
    //     melody: [
    //         // Parte inicial de la melodía de "Ode to Joy"
    //         ['0:0:0', 'E4'],
    //         ['0:0:2', 'E4'],
    //         ['0:1:0', 'F4'],
    //         ['0:1:2', 'G4'],
    //         ['0:2:0', 'G4'],
    //         ['0:2:2', 'F4'],
    //         ['0:3:0', 'E4'],
    //         ['0:3:2', 'D4'],
    //         ['1:0:0', 'C4'],
    //         ['1:0:2', 'C4'],
    //         ['1:1:0', 'D4'],
    //         ['1:1:2', 'E4'],
    //         ['1:2:0', 'E4'],
    //         ['1:2:2', 'D4'],
    //         ['1:3:0', 'D4'],
    //         // Repite o continúa la melodía según sea necesario
    //     ],
    //     // Puedes agregar acordes o acompañamiento si lo deseas
    // };

    // let melodyPart = new Tone.Part((time, note) => {
    //     synth.triggerAttackRelease(note, '8n', time);
    // }, odeToJoyPatterns.melody).start(0);

    // melodyPart.loop = true;
    // melodyPart.loopStart = 0;
    // melodyPart.loopEnd = '2:0:0';


    return (

        <div>
            {/* <GridTest /> */}
            <div className="piano">
                {pianoNotes.map(({ note, type }) => (
                    <PianoKey key={note} note={note} type={type} />
                ))}
            </div>

            <button onClick={handlePlay}>Play</button>
            <button onClick={handleStop}>Stop</button>

            {/* <button onclick="Play()">Play</button> */}
            <div ref={drop} className="pianoRoll">


                {/* Renderiza la matriz de acordes */}
                {matrix.map((row, rowIndex) => (
                    <div key={rowIndex} className="timeline-row">

                        {row.map((notes, colIndex,) => (
                            <Cell key={`${rowIndex} - ${colIndex}`} rowIndex={rowIndex} colIndex={colIndex} notes={notes}
                                onClick={() => handleCellClick(rowIndex, colIndex,)}

                            />

                        ))}
                    </div>
                ))}

                {/* Renderiza los acordes existentes */}
                {chords.map((chord, index) => (
                    <div key={index} className="note" style={{ left: `${chord.position}px` }}>
                        {chord.name}
                    </div>
                ))}
            </div>
            <div>
                <label htmlFor="bpm">BPM:</label>
                <input
                    type="number"
                    id="bpm"
                    value={bpm}
                    onChange={(e) => setBpm(Number(e.target.value))}
                />
            </div>
        </div >

    );
};




import React from 'react';
import './gridtest.css'; // Asegúrate de que este archivo CSS esté creado y correctamente vinculado
import Cell from './Cell.tsx'; // Asegúrate de que el componente Cell esté correctamente importado
import { useDispatch, useSelector } from 'react-redux';
import { insertInMatrix, toggleCell } from './timelineslice.ts';

export const Gridtest = ({ slots, notes }) => {
    const numberOfRows = 12; // Número de filas en el grid
    const numberOfColumns = 20; // Número de columnas en el grid
    const dispatch = useDispatch();
    const { cells } = useSelector((state) => state.timeline);

    // Función para obtener las notas de una posición específica
    const getNotesForPosition = (rowIndex, colIndex) => {
        const positionKey = `${rowIndex}:${colIndex}`;
        return slots[positionKey] || [];
    };
    const handleCellClick = (rowIndex, colIndex) => {
        const octavaC4aB4 = {
            0: "C4",
            1: "C#4 / Db4",
            2: "D4",
            3: "D#4 / Eb4",
            4: "E4",
            5: "F4",
            6: "F#4 / Gb4",
            7: "G4",
            8: "G#4 / Ab4",
            9: "A4",
            10: "A#4 / Bb4",
            11: "B4"
        };
        const note = octavaC4aB4[rowIndex];

        dispatch(toggleCell({ position: `${rowIndex}:${colIndex}`, rowIndex, columnIndex: colIndex, note }));

        // dispatch(toggleCell({ rowIndex, columnIndex: colIndex, note }));
    };

    // const handleCellClick = (rowIndex, colIndex) => {
    //     const octavaC4aB4 = {
    //         0: "C4",
    //         1: "C#4 / Db4",
    //         2: "D4",
    //         3: "D#4 / Eb4",
    //         4: "E4",
    //         5: "F4",
    //         6: "F#4 / Gb4",
    //         7: "G4",
    //         8: "G#4 / Ab4",
    //         9: "A4",
    //         10: "A#4 / Bb4",
    //         11: "B4"
    //     };
    //     const note = octavaC4aB4[rowIndex];


    //     dispatch(toggleCellMark({ position: `${rowIndex}:${colIndex}`, rowIndex, columnIndex: colIndex, note }));
    // };
    return (
        <div className="grids">
            {Array.from({ length: numberOfRows }).map((_, rowIndex) => (
                <div key={rowIndex} className="grid-rows">
                    {Array.from({ length: numberOfColumns }).map((_, colIndex) => (
                        <Cell
                            key={`${rowIndex}-${colIndex}`} // Modificado para asegurar una clave única por celda
                            rowIndex={rowIndex}
                            colIndex={colIndex}
                            notes={getNotesForPosition(rowIndex, colIndex)} // Pasamos las notas específicas para esta celda
                            data-row={rowIndex} data-col={colIndex}

                            onClick={handleCellClick}
                        />
                    ))}
                </div>
            ))}
        </div>
    );
};





///////////////////////////////////////////////

import React, { useRef, useEffect } from 'react';
import './gridtest.css';
import { useDispatch, useSelector } from 'react-redux';
import { toggleCell } from './timelineslice.ts';

export const Gridtest = ({ slots }) => {
    const canvasRef = useRef(null);
    const dispatch = useDispatch();
    const numberOfRows = 12;
    const numberOfColumns = 20;
    const cellSize = 20; // Tamaño de cada celda en píxeles

    useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        drawGrid(ctx);
    }, []);

    const drawGrid = (ctx) => {
        for (let row = 0; row < numberOfRows; row++) {
            for (let col = 0; col < numberOfColumns; col++) {
                ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
            }
        }
    };

    const handleCanvasClick = (event) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const colIndex = Math.floor(x / cellSize);
        const rowIndex = Math.floor(y / cellSize);

        // Aquí, calcula qué celda ha sido clickeada basado en x, y
        console.log(`Celda en columna: ${colIndex}, fila: ${rowIndex} clickeada`);

        // Dispatch a Redux action here
        // dispatch(toggleCell({ rowIndex, colIndex }));
    };

    return (
        <div className="grid-canvas-container">
            <canvas
                ref={canvasRef}
                width={numberOfColumns * cellSize}
                height={numberOfRows * cellSize}
                onClick={handleCanvasClick}
                className="grid-canvas"
            />
        </div>
    );
};
///////////////////////////////////////////////////////////////



return (
    <div className="grid">
        {Array.from({ length: numberOfRows }).map((_, rowIndex) => (
            <div key={rowIndex} className="grid-row">
                {Array.from({ length: numberOfColumns }).map((_, colIndex) => {
                    const positionKey = `${rowIndex}:${colIndex}`;
                    const isMarked = slots[positionKey] && slots[positionKey].length > 0;
                    return (
                        <Cell
                            key={`${rowIndex}-${colIndex}`}
                            rowIndex={rowIndex}
                            colIndex={colIndex}
                            isMarked={isMarked}
                            onClick={() => handleCellClick(rowIndex, colIndex, positionKey)}
                        />
                    );
                })}
            </div>
        ))}
    </div>
);
};
